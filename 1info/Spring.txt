Spring tool suite https://start.spring.io/
from Spring 4.0 we need minimum java6 and supports 7 and 8
from Spring 5.0 we need java8

we can define any util calss as Component to autowaire in another class
java beans should not be as final class to work as spring beans

The default scope is singleton, but you can override this with the @Scope annotation

Core Container
---------------------------------------------------
The Core Container consists of the spring-core, spring-beans, spring-context, spring-context-support, and spring-expression (Spring Expression Language) modules.
spring-context-support provides support for integrating common third-party libraries into a Spring application context for caching (EhCache, Guava, JCache), mailing (JavaMail), scheduling (CommonJ, Quartz) and template engines (FreeMarker, JasperReports, Velocity).

ApplicationContext is a sub-interface of BeanFactory
the BeanFactory provides the configuration framework and basic functionality
the ApplicationContext adds more enterprise-specific functionality

Naming beans:
In XML-based configuration metadata, you use the id and/or name attributes to specify the bean identifier(s). The id attribute allows you to specify exactly one id.
If you want to introduce other aliases to the bean, you can also specify them in the name attribute, separated by a comma (,), semicolon (;), or white space. 
Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. 
<alias name="fromName" alias="toName"/>

Motivations for not supplying a name are related to using inner beans and autowiring collaborators.

Instantiating beans:
 If you want to configure a bean definition for a static nested class, you have to use the binary name of the nested class. 
 class="com.example.Foo$Bar"
Instantiation with a static factory method
The following bean definition specifies that the bean will be created by calling a factory-method. The definition does not specify the type (class) of the returned object, only the class containing the factory method.  
 <bean id="clientService" class="examples.ClientService"    factory-method="createInstance"/>

Instantiation using an instance factory method
we use factory-bean attribute

Dependency Injection:
your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>

Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the @Required annotation on a setter method can be used to make the property a required dependency.  Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.

Resource resource=new ClassPathResource("applicationContext.xml");  
BeanFactory factory=new XmlBeanFactory(resource); 

ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  

<bean id="e" class="com.javatpoint.Employee">  
	<constructor-arg value="10" type="int"></constructor-arg>  
</bean>  
<constructor-arg>  
	<list>  
	<value>Java is a programming language</value>  
	<value>Java is a Platform</value> 
	</list>  
</constructor-arg>  
 
<constructor-arg>  
<list>  
	<ref bean="ans1"/>  
	<ref bean="ans2"/>  
</list>  
</constructor-arg> 

<constructor-arg>  
<map>  
	<entry key="Java is a Programming Language"  value="Ajay Kumar"></entry>  
	<entry key="Java is a Platform" value="John Smith"></entry>
</map>  
</constructor-arg> 

<property name="answers">  
	<list>  
	<value>Java is a programming language</value>  
	<value>Java is a Platform</value> 
	</list>  
</property>

private Map<Answer,User> answers;  
<property name="answers">  
	<map>  
	<entry key-ref="answer1" value-ref="user1"></entry>  
	<entry key-ref="answer2" value-ref="user2"></entry>  
	</map>  
</property>  
using parent
<bean id="e1" class="com.javatpoint.Employee">  
	<constructor-arg value="101"></constructor-arg>  
	<constructor-arg  value="Sachin"></constructor-arg>  
</bean> 
<bean id="e2" class="com.javatpoint.Employee" parent="e1">  
	<constructor-arg ref="address1"></constructor-arg>  
</bean> 

  
Java bassed configuration
***************************
@Configuration
public class AppConfig {
	@Bean
	public MyService myService() {
	return new MyServiceImpl();
	}
}
When @Bean methods are declared within classes that are not annotated with @Configuration they are referred to as being processed in a lite mode.
Unlike full @Configuration, lite @Bean methods cannot easily declare inter-bean dependencies.

public static void main(String[] args) {
	ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
	MyService myService = ctx.getBean(MyService.class);
	myService.doStuff();
}

@Configuration
@ComponentScan(basePackages = "com.acme")
public class AppConfig {
...
}
In the example above, the com.acme package will be scanned, looking for any @Componentannotated classes, and those classes will be registered as Spring bean definitions within the container.
A WebApplicationContext variant of AnnotationConfigApplicationContext is available with AnnotationConfigWebApplicationContext. This implementation may be used when configuring the Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, etc.

@Bean annotation supports some of the attributes offered by <bean/>, such as: init-method, destroy-method, autowiring and name.
Any classes defined with the @Bean annotation support the regular lifecycle callbacks and can use the @PostConstruct and @PreDestroy annotations from JSR-250
The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s init-method and destroy-method attributes on the bean element
public class Foo {
	public void init() { // initialization logic }
}
public class Bar {
	public void cleanup() {	// destruction logic 	}
}
@Configuration
public class AppConfig {
	@Bean(initMethod = "init")
	public Foo foo() { 	return new Foo(); 	}
	@Bean(destroyMethod = "cleanup")
	public Bar bar() { 	return new Bar(); 	}
}
The default scope is singleton, but you can override this with the @Scope annotation
@Configuration
public class MyConfiguration {
	@Bean
	@Scope("prototype")
	public Encryptor encryptor() { 	// ... 	}
}
@Bean(name = "myFoo")
public Foo foo() {	return new Foo(); }
@Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })
public DataSource dataSource() {}
//<import/>
@Configuration
public class ConfigA { }
@Configuration
@Import(ConfigA.class)
public class ConfigB {}

//bean dependecy with another bean which is in different config class
@Configuration
public class RepositoryConfig {
	@Autowired
	private DataSource dataSource;
	@Bean
	public AccountRepository accountRepository() {
	return new JdbcAccountRepository(dataSource);
	}
}
@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {
	@Bean
	public DataSource dataSource() {
	// return new DataSource
	}
}

8. Resources
--------------------------------------------------
Java’s standard java.net.URL class and standard handlers for various URL prefixes unfortunately are not quite adequate enough for all access to low-level resources.
While the Resource interface is used a lot with Spring and by Spring, it’s actually very useful to use as a general utility class by itself in your own code, for access to resources, even when your code doesn’t know or care about any other parts of Spring.
Built-in Resource implementations:  UrlResource, ClassPathResource, FileSystemResource, ServletContextResource
The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.
public interface ResourceLoader {
    Resource getResource(String location);
}
All application contexts implement the ResourceLoader interface, and therefore all application contexts may be used to obtain Resource instances.
ClassPathXmlApplicationContext ctx=.....
Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
the above snippet returns ClassPathResource.
FileSystemXmlApplicationContext uses FileSystemResource
WebApplicationContext returns ServletContextResource
we can also force contexts to use specific resource like below
Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");


9. Validation, Data Binding, and Type Conversion
-----------------------------------------------------------
Spring features a Validator interface that you can use to validate objects. we need to impliment below methods
• supports(Class) - Can this Validator validate instances of the supplied Class? 
• validate(Object, org.springframework.validation.Errors) - validates the given object and in case of validation errors, registers those with the given Errors object 
public class Person {
    private String name;
    private int age;
}
public class PersonValidator implements Validator {
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() < 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() > 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}
While it is certainly possible to implement a single Validator class to validate each of the nested objects in a rich object, it may be better to encapsulate the validation logic for each nested class of object in its own Validator implementation. A simple example of a 'rich' object would be a Customer that is composed of two String properties (a first and second name) and a complex Address object. Address objects may be used independently of Customer objects, and so a distinct AddressValidator has been implemented. If you want your CustomerValidator to reuse the logic contained within the AddressValidator class without resorting to copy-and-paste, you can dependency-inject or instantiate an AddressValidator within your CustomerValidator, and use it
public class CustomerValidator implements Validator {
    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }
    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}
Validation errors are reported to the Errors object passed to the validator. In case of Spring Web MVC you can use <spring:bind/> tag to inspect the error messages, but of course you can also inspect the errors object yourself. 

11 Aspect Oriented Programming with Spring
-----------------------------------------------------------
Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object does not implement an interface.
Types of advice:
Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception). 
• After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception. 
• After throwing advice: Advice to be executed if a method exits by throwing an exception. 
• After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return). 
• Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation

Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. 

Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. If you need to advise field access and update join points, consider a language such as AspectJ.

Enabling @AspectJ Support with Java configuration
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
Enabling @AspectJ Support with XML configuration
<aop:aspectj-autoproxy/>

we need aspectjweaver.jar 
Declaring an aspect: annotate classes with @Aspect
Declaring a pointcut: A pointcut declaration has two parts: a signature comprising a name and any parameters, and a pointcut expression that determines exactly which method executions we are interested in. the method serving as the pointcut signature must have a void return type

@Pointcut("execution(* transfer(..))")// the pointcut expression
private void anyOldTransfer() {}// the pointcut signature
Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions:
• execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP 
• within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP) 
and -this -target args -@target, @args, @within, @annotation

Declaring advice
@Aspect
public class BeforeExample {
    @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }
}

@Aspect
public class AfterReturningExample {
    @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }

}


--------------------------------------------------
Global transactions
Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API to use (partly due to its exception model). Furthermore, a JTA UserTransaction normally needs to be sourced from JNDI, meaning that you also need to use JNDI in order to use JTA. Obviously the use of global transactions would limit any potential reuse of application code, as JTA is normally only available in an application server environment.
The significant downside is that CMT is tied to JTA and an application server environment.

Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources. 

you do not need an application server simply for declarative transactions through EJBs. Typically you need an application server’s JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. 

The Spring Framework provides both declarative and programmatic transaction management. Most users prefer declarative transaction management, which is recommended in most cases.
With programmatic transaction management, developers work with the Spring Framework transaction abstraction, which can run over any underlying transaction infrastructure. With the preferred declarative model, developers typically write little or no code related to transaction management, and hence do not depend on the Spring Framework transaction API, or any other transaction API.
Transactional code can be tested much more easily than if it used JTA directly.
the TransactionException that can be thrown by any of the PlatformTransactionManager interface’s methods is unchecked
public interface PlatformTransactionManager {
	TransactionStatus getTransaction( TransactionDefinition definition) throws TransactionException;
	void commit(TransactionStatus status) throws TransactionException;
	void rollback(TransactionStatus status) throws TransactionException;
}
The getTransaction(..) method returns a TransactionStatus object, depending on a TransactionDefinition parameter. The returned TransactionStatus might represent a new transaction, or can represent an existing transaction if a matching transaction exists in the current call stack.
The TransactionStatus interface provides a simple way for transactional code to control transaction execution and query transaction status.
public interface TransactionStatus extends SavepointManager {
	boolean isNewTransaction();
	boolean hasSavepoint();
	void setRollbackOnly();
	boolean isRollbackOnly();
	void flush();
	boolean isCompleted();
}
PlatformTransactionManager implementations normally require knowledge of the environment in which they work: JDBC, JTA, Hibernate, and so on.
a local PlatformTransactionManager implementation example for JDBC
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
	<property name="driverClassName" value="${jdbc.driverClassName}" />
	<property name="url" value="${jdbc.url}" />
	<property name="username" value="${jdbc.username}" />
	<property name="password" value="${jdbc.password}" />
</bean>
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"/>
</bean>
If you use JTA in a Java EE container then you use a container DataSource, obtained through JNDI, in conjunction with Spring’s JtaTransactionManager.
	<jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>
	<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />
The JtaTransactionManager does not need to know about the DataSource, or any other specific resources, because it uses the container’s global transaction management infrastructure.
You can also use Hibernate local transactions easily. The txManager bean in this case is of the HibernateTransactionManager type. In the same way as the DataSourceTransactionManager needs a reference to the DataSource, the HibernateTransactionManager needs a reference to the SessionFactory.
<bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
	<property name="dataSource" ref="dataSource" />
	<property name="mappingResources">
	<list>
	<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
	</list>
	</property>
	<property name="hibernateProperties">
	<value>
	hibernate.dialect=${hibernate.dialect}
	</value>
	</property>
</bean>
<bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
	<property name="sessionFactory" ref="sessionFactory" />
</bean>
If you are using Hibernate and Java EE container-managed JTA transactions, then you should simply use the same JtaTransactionManager as in the previous JTA example for JDBC.
<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>

######################################################
#########         Spring MVC        ##################
######################################################
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>4.3.6.RELEASE</version>
</dependency>
<web-app>
	<servlet>
		<servlet-name>example</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>example</servlet-name>
		<url-pattern>/example/*</url-pattern>
	</servlet-mapping>
</web-app>
register custom configuration class
<web-app>
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/root-context.xml</param-value>
	</context-param>
	<servlet>
	<servlet-name>dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value></param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>dispatcher</servlet-name>
		<url-pattern>/*</url-pattern>
	</servlet-mapping>
	<listener>
		istener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
</web-app>
both DispatcherServlet and ContextLoaderListener loads configuraion. ContextLoaderListener loads context based on path-value in context parameter
DispatcherServlet loads context based on path-value in init parameter
if we want to use DispatcherServlet configuration with xml and context configuration with annotation the we need context parameter with contextClass.
<context-param>
	<param-name>contextClass</param-name>
	<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext
	</param-value>
</context-param>
//general way of DispatcherServlet registration i.e servlet 3.0 configuration
public class MyWebApplicationInitializer implements WebApplicationInitializer {
	@Override
	public void onStartup(ServletContext container) {
		ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new
		DispatcherServlet());
		registration.setLoadOnStartup(1);
		registration.addMapping("/example/*");
	}
}
//more srping specific way of DispatcherServlet registration
public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
	@Override
	protected String[] getServletMappings() {
	return new String[] { "/" };
	}
	@Override
	protected Class<?>[] getRootConfigClasses() {
	return new Class<?>[] { RootConfig.class };
	}
	@Override
	protected Class<?>[] getServletConfigClasses() {
	return new Class<?>[] { WebConfig.class };
	}
	@Override
	protected Filter[] getServletFilters() {// to add filters to DispatcherServlet
	return new Filter[] { new MyFilter() };
	}
}
AbstractAnnotationConfigDispatcherServletInitializer is implimentation of WebApplicationInitializer
//to add more servlets or filters we can add as many WebApplicationInitializer we need.
public class MyWebApplicationInitializer1 implements WebApplicationInitializer {
	@Override
	public void onStartup(ServletContext servletContext) {
		javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter("myFilter", MyFilter.class);
		filter.addMappingForUrlPatterns(null, false, "/custom/*");
	}
}

ENABLING SPRING MVC
	option1: there’s an <mvc:annotation-driven> element that you can use to enable annotation-driven Spring MVC.
	option2:@EnableWebMvc
		@Configuration
		@EnableWebMvc
		public class WebConfig {
		}
the above does not do features like view resolver, component scan and static content handling, we have to configure those
@Configuration
@EnableWebMvc
@ComponentScan("spitter.web")
public class WebConfig extends WebMvcConfigurerAdapter {
	@Bean
	public ViewResolver viewResolver() {
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix("/WEB-INF/views/");
		resolver.setSuffix(".jsp");
		resolver.setExposeContextBeansAsAttributes(true);
		return resolver;
	}
	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}
}
@Controller
public class HomeController {
	@RequestMapping(value="/", method=GET)
	public String home() {
		return "home";
	}
}
here return string is considered as view name(not response like RestController)
@Controller
@RequestMapping({"/", "/homepage"})
public class HomeController {
	.....
}
@RequestMapping(method=RequestMethod.GET)
public String spittles(Map model) {
	model.put("spittleList",spittleRepository.findSpittles(Long.MAX_VALUE, 20));
	return "spittles";
}
here view name is spittles
@RequestMapping(method=RequestMethod.GET)
public List<Spittle> spittles() {
	return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
}
here retype is not view. it is object(Model or collection) So view nmae is comes from path mapping.
the model data is copied into the request as request attributes.
@RequestMapping(method=RequestMethod.GET)
public String spittles(Map model) {
	model.put("spittleList",spittleRepository.findSpittles(Long.MAX_VALUE, 20));
	return "spittles";
}
we can also use map as model to write spring free code.
//Taking input via path parameters
/spittles/12345 is better than one for /spittles/show?spittle_id=12345 as per resource-orientation perspective.
@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
public String spittle(@PathVariable("spittleId") long spittleId, Model model) {
	model.addAttribute(spittleRepository.findOne(spittleId));
	return "spittle";
}

special beans
HandlerMapping: Maps incoming requests to handlers
HandlerAdapter: Helps the DispatcherServlet to invoke a handler
ViewResolver: Resolves logical String-based view names to actual View types.
HandlerExceptionResolver: Maps exceptions to views
for each special bean the DispatcherServlet maintains a list of implementations to use by default. This information is kept in the file DispatcherServlet.properties
For example if you configure an InternalResourceViewResolver, the default list of ViewResolver implementations is ignored.

Spring 2.5 introduced an annotation-based programming model for MVC controllers that uses annotations such as @RequestMapping, @RequestParam, @ModelAttribute, and so on.
@Controller
public class HelloWorldController {
	@RequestMapping("/helloWorld")
	public String helloWorld(Model model) {
		model.addAttribute("message", "Hello World!");
		return "helloWorld";
	}
}
To enable autodetection of such annotated controllers, you add component scanning to your configuration.
<context:component-scan base-package="org.springframework.samples.petclinic.web"/>
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {
	private final AppointmentBook appointmentBook;
	@Autowired
	public AppointmentsController(AppointmentBook appointmentBook) {
		this.appointmentBook = appointmentBook;
	}
	@RequestMapping(method = RequestMethod.GET)
	public Map<String, Appointment> get() {
	return appointmentBook.getAppointmentsForToday();
	}
	@RequestMapping(value="/{day}", method = RequestMethod.GET)
	public Map<String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day,
	Model model) {
	return appointmentBook.getAppointmentsForDay(day);
	}
	@RequestMapping(value="/new", method = RequestMethod.GET)
	public AppointmentForm getNewForm() {
	return new AppointmentForm();
	}
	@RequestMapping(method = RequestMethod.POST)
	public String add(@Valid AppointmentForm appointment, BindingResult result) {
	if (result.hasErrors()) {
	return "appointments/new";
	}
	appointmentBook.addAppointment(appointment);
	return "redirect:/appointments";
	}
}
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String theOwner, Model model) {
	// implementation omitted
}
A @PathVariable argument can be of any simple type such as int, long, Date, etc. 
Spring automatically converts to the appropriate type or throws a TypeMismatchException if it fails to do so.
@Controller
@RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json", produces="application/json")
public void addPet(@RequestBody Pet pet, Model model) {
// implementation omitted
}
Supported method argument types
	Request or response objects(ServletRequest or HttpServletRequest)
	Session object (HttpSession)
	WebRequest, NativeWebRequest, java.util.Locale, java.util.TimeZone, java.io.InputStream / java.io.Reader, java.io.OutputStream / java.io.Writer
	@PathVariable @RequestParam @RequestHeader @RequestBody @RequestPart HttpEntity<?>
	Command or form objects to bind request parameters to bean properties
	Errors, BindingResult
@RequestMapping(method = RequestMethod.POST)
public String processSubmit(@ModelAttribute("pet") Pet pet, Model model, BindingResult result) { ... }
Invalid ordering of BindingResult and @ModelAttribute there is a Model parameter in between Pet and BindingResult.
@RequestMapping(method = RequestMethod.POST)
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result, Model model) { ... }

new controler annotations from 4.3 @GetMapping ,@PostMapping ,@PutMapping ,@DeleteMapping ,@PatchMapping
@PathVariable can be used to mapp URI templete to method parameter

@PostMapping(path = "/pets", consumes = "application/json")
@GetMapping(path = "/pets/{petId}", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)


Handler mappings:
----------------------
In previous versions of Spring, users were required to define one or more HandlerMapping beans in the web application context to map incoming web requests to appropriate handlers. With the introduction of annotated controllers, you generally don’t need to do that because the RequestMappingHandlerMapping automatically looks for @RequestMapping annotations on all @Controller beans. However, do keep in mind that all HandlerMapping classes extending from AbstractHandlerMapping have the properties that you can use to customize their behavior

Interceptors can be configured using the interceptors property, which is present on all HandlerMapping classes extending from AbstractHandlerMapping

Interceptors located in the handler mapping must implement HandlerInterceptor from the org.springframework.web.servlet package. This interface defines three methods: preHandle(..) is called before the actual handler is executed; postHandle(..) is called after the handler is executed; and afterCompletion(..) is called after the complete request has finished. 

the Spring adapter class HandlerInterceptorAdapter makes it easier to extend the HandlerInterceptor interface.

Resolving views
---------------------------
The two interfaces that are important to the way Spring handles views are ViewResolver and View. The ViewResolver provides a mapping between view names and actual views. The View interface addresses the preparation of the request and hands the request over to one of the view technologies.

AbstractCachingViewResolver
XmlViewResolver   looks into views.xml
ResourceBundleViewResolver  looks into views.properties
UrlBasedViewResolver
InternalResourceViewResolver subclass of UrlBasedViewResolver



//multipart resolver
DispatcherServlet doesn’t implement any logic for parsing the data in a multipart request. Instead, it delegates to an implementation of Spring’s MultipartResolver strategy interface to resolve the content in a multipart request.
CommonsMultipartResolver—Resolves multipart requests using Jakarta Commons FileUpload (even before Spring 3.1)
StandardServletMultipartResolver—Relies on Servlet 3.0 support for multipart requests (since Spring 3.1)
@Bean
public MultipartResolver multipartResolver() throws IOException {
	return new StandardServletMultipartResolver();
}
public class MyWebApplicationInitializer implements WebApplicationInitializer {
	@Override
	public void onStartup(ServletContext context) {
	DispatcherServlet ds = new DispatcherServlet();
	Dynamic registration = context.addServlet("appServlet", ds);
	registration.addMapping("/");
	registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
	}
}
public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
-----
	@Override
	protected void customizeRegistration(Dynamic registration) {
	registration.setMultipartConfig(
		new MultipartConfigElement("/tmp/spittr/uploads"));
	}
}
For example, suppose you want to limit files to no more than 2 MB, to limit the entire request to no more than 4 MB, and to write all files to disk.
new MultipartConfigElement("/tmp/spittr/uploads",2097152, 4194304, 0));

<input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif" /><br/>
@RequestMapping(value="/register", method=POST)
public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture, @Valid Spitter spitter, Errors errors) {
	...
}
##########################################
##########  Handling exceptions  #########
##########################################
Certain Spring exceptions are automatically mapped to specific HTTP status codes.
MissingServletRequestParameterException   400 - Bad Request
MissingServletRequestPartException        400 - Bad Request
MethodArgumentNotValidException           400 - Bad Request
TypeMismatchException                     400 - Bad Request
NoSuchRequestHandlingMethodException      404 - Not Found
Although these built-in mappings are helpful, they do not do good for any application exceptions that may be thrown.
@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
public String spittle(@PathVariable("spittleId") long spittleId, Model model) {
	Spittle spittle = spittleRepository.findOne(spittleId);
	if (spittle == null) {
	throw new SpittleNotFoundException();
	}
	model.addAttribute(spittle);
	return "spittle";
}
package spittr.web;
@ResponseStatus(value=HttpStatus.NOT_FOUND, reason="Spittle Not Found")
public class SpittleNotFoundException extends RuntimeException {
}
//handling exceptions with methods
@ExceptionHandler(DuplicateSpittleException.class)
public String handleDuplicateSpittle() {
return "error/duplicate";
}
What’s especially interesting about @ExceptionHandler methods is that they handle their exceptions from any handler method in the same controller.
@ControllerAdvice
public class AppWideExceptionHandler {
	@ExceptionHandler(DuplicateSpittleException.class)
	public String duplicateSpittleHandler() {
		return "error/duplicate";
	}
}
from Spring 3.2 we can use ControllerAdvice to handle same exception from multiple controllers



what are RequestMappingHandlerMapping and AbstractHandlerMapping
How to use Consumes/produces mediaType?
How to enable autodetection of annotated controllers?
whar are the init parameters of DispatchServlet?
what are different types of special beans in Spring MVC?
how to configure Dispatchservlet and webcontext?

######################################################
##############  Spring Database  #####################
######################################################
oracle.jdbc.driver.OracleDriver
com.mysql.jdbc.Driver

Spring framework provides following approaches for JDBC database access:
 JdbcTemplate
 NamedParameterJdbcTemplate
 SimpleJdbcTemplate
 SimpleJdbcInsert and SimpleJdbcCall

<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
	<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
	<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
	<property name="username" value="system" />  
	<property name="password" value="oracle" />  
</bean>  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
	<property name="dataSource" ref="ds"></property>  
</bean>  
 
<bean id="edao" class="com.javatpoint.EmployeeDao">  
	<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>
@Bean
public DataSource dataSource() {
	DriverManagerDataSource ds = new DriverManagerDataSource();
	ds.setDriverClassName("org.h2.Driver");
	ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
	ds.setUsername("sa");
	ds.setPassword("");
	return ds;
} 
DriverManagerDataSource—Returns a new connection every time a connection is requested.
SingleConnectionDataSource—Returns the same connection every time a connection is requested.

@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
	return new JdbcTemplate(dataSource);
}
@Bean
public EmployeeDao empRepository(JdbcTemplate jdbcTemplate) {
	return new EmployeeDao(jdbcTemplate);
}
or
@Repository
public class JdbcEmployeeRepository implements EmployeeRepository {
	private JdbcOperations jdbcOperations;
	@Inject
	public JdbcSpitterRepository(JdbcOperations jdbcOperations) {
	this.jdbcOperations = jdbcOperations;
	}
}
//get jdbc templete with jndi
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
		<property name="dataSource" ref="dataSource2"></property>  
	</bean> 
	<bean id="dataSource2" class="org.springframework.jndi.JndiObjectFactoryBean">
		<property name="jndiName">
			<value>jdbc/pds</value>
		</property>
	</bean>
//get data source with Java configuration
@Bean
public JndiObjectFactoryBean dataSource() {
	JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
	jndiObjectFB.setJndiName("jdbc/SpittrDS");
	jndiObjectFB.setResourceRef(true);
	jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
	return jndiObjectFB;
}
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
	return new JdbcTemplate(dataSource);
}
public class EmployeeDao {  
	private JdbcTemplate jdbcTemplate;  
	public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  
		this.jdbcTemplate = jdbcTemplate;  
	}  
	public int saveEmployee(Employee e){  
     String query="insert into employee values(  
     '"+e.getId()+"','"+e.getName()+"','"+e.getSalary()+"')";  
     return jdbcTemplate.update(query);  
	}  
}

//JDBC templete with prepared statement
public Boolean saveEmployeeByPreparedStatement(final Employee e){  
    String query="insert into employee values(?,?,?)";  
    return jdbcTemplate.execute(query,new PreparedStatementCallback<Boolean>(){  
    @Override  
    public Boolean doInPreparedStatement(PreparedStatement ps)  
            throws SQLException, DataAccessException {  
        ps.setInt(1,e.getId());  
        ps.setString(2,e.getName());  
        ps.setFloat(3,e.getSalary());  
        return ps.execute();  
    }  
    });  
}  

//JDBC templete with resultSet
public List<Employee> getAllEmployees(){  
	return jdbcTemplate.query("select * from employee",new ResultSetExtractor<List<Employee>>(){  
		@Override  
		public List<Employee> extractData(ResultSet rs) throws SQLException,  
				DataAccessException {  
        List<Employee> list=new ArrayList<Employee>();  
		while(rs.next()){  
			Employee e=new Employee();  
			e.setId(rs.getInt(1));  
			e.setName(rs.getString(2));  
			e.setSalary(rs.getInt(3));  
			list.add(e);  
			}  
			return list;  
        }  
    });  
 } 
 
 //JDBC templete with rowmapper
 public T mapRow(ResultSet rs, int rowNumber)throws SQLException  
 
public List<Employee> getAllEmployeesRowMapper(){  
	return jdbcTemplate.query("select * from employee",new RowMapper<Employee>(){  
		@Override  
		public Employee mapRow(ResultSet rs, int rownumber) throws SQLException {  
			Employee e=new Employee();  
			e.setId(rs.getInt(1));  
			e.setName(rs.getString(2));  
			e.setSalary(rs.getInt(3));  
			return e;  
		}  
		});  
}

//NamedParameterJdbcTemplate
pubic T execute(String sql,Map map,PreparedStatementCallback psc)  
<bean id="jtemplate"   
	class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">  
	<constructor-arg ref="ds"></constructor-arg>  
</bean>
public  void save (Emp e){  
	String query="insert into employee values (:id,:name,:salary)";  
	Map<String,Object> map=new HashMap<String,Object>();  
	map.put("id",e.getId());  
	map.put("name",e.getName());  
	map.put("salary",e.getSalary());  
	template.execute(query,map,new PreparedStatementCallback() {  
		@Override  
		public Object doInPreparedStatement(PreparedStatement ps)  
				throws SQLException, DataAccessException {  
			return ps.executeUpdate();  
		}  
	});  
}  

//SimpleJdbcTemplate
int update(String sql,Object... parameters)  
<bean id="jtemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate">  
	<constructor-arg ref="ds"></constructor-arg>  
</bean> 
public int update (Emp e){  
	String query="update employee set name=? where id=?";  
	return template.update(query,e.getName(),e.getId());  
}

How to use Repositories
@Configuration 
@EnableJpaRepositories("com.concretepage.repository")
public class JPAConfig {
}
public interface ArticleRepository extends CrudRepository<Article, Long>  {
}
public class ArticleService {
   @Autowired
   private ArticleRepository articleRepository;
   ------
}
Article savedArticle = articleRepository.save(article); 
Article obj = articleRepository.findById(articleId).get();
Iterable<Article> articles = articleRepository.findAll(); 

//Using a pooled data source
If you’re unable to retrieve a data source from JNDI, the next best thing is to configure
a pooled data source directly in Spring. Although Spring doesn’t provide a pooled
data source, plenty of suitable ones are available, including the following open source
>Apache Commons DBCP (http://jakarta.apache.org/commons/dbcp)
>c3p0 (http://sourceforge.net/projects/c3p0/)
>BoneCP (http://jolbox.com/)
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
	p:driverClassName="org.h2.Driver"
	p:url="jdbc:h2:tcp://localhost/~/spitter"
	p:username="sa"
	p:password=""
	p:initialSize="5"
	p:maxActive="10" />
@Bean
public BasicDataSource dataSource() {
	BasicDataSource ds = new BasicDataSource();
	ds.setDriverClassName("org.h2.Driver");
	ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
	ds.setUsername("sa");
	ds.setPassword("");
	ds.setInitialSize(5);
	ds.setMaxActive(10);
	return ds;
}
//Using profiles to select a data source
@Configuration
public class DataSourceConfiguration {
	@Profile("development")
	@Bean
	public DataSource embeddedDataSource() {}
	
	@Profile("qa")
	@Bean
	public DataSource Data() {}
}

//how to work with multiple databases/schemas
Configure multiple database properties in application.yml
@Configuration
public class AppConfig {
	@Bean(name = "dbProfileService")
	@ConfigurationProperties(prefix = "spring.dbProfileService")
	public DataSource createProfileServiceDataSource() {
		return DataSourceBuilder.create().build();
	}

	@Bean(name = "dbTaskService")
	@ConfigurationProperties(prefix = "spring.dbTaskService")
	public DataSource createTaskServiceDataSource() {
		return DataSourceBuilder.create().build();
	}

	@Bean(name = "jdbcProfileService")
	@Autowired
	public JdbcTemplate creuteJdbcTemplute_ProfileService(@Qualifier("dbProfileService") DataSource prafileServiceDS) {
		return new JdbcTemplate(prafileServiceDS);
	}
	
	@Bean(name = "jdbcTaskService")
	@Autowired
	public JdbcTemplate creuteJdbcTemplute_TaskService(@Qualifier("dbTaskService") DataSource dbServiceDS) {
		return new JdbcTemplate(dbServiceDS);
	}
}
@Repository
public class Dao1 {
	@Qualifier("jdbcProfileService")
	@Autowired
	JdbcTemplate jt;
	public int getCountUsers(){
		return jt.queryForObject("", Integer.class);
	}
}

Hibernate 3.2 and below 4.0 and xml mappings
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
	LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
	sfb.setDataSource(dataSource);
	sfb.setMappingResources(new String[] { "Spitter.hbm.xml" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}
Hibernate 3.2 and below 4.0 and annotation-oriented persistence
@Bean
public AnnotationSessionFactoryBean sessionFactory(DataSource ds) {
	AnnotationSessionFactoryBean sfb = new AnnotationSessionFactoryBean();
	sfb.setDataSource(ds);
	sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}
if you’re using Hibernate 4, you should use the LocalSessionFactoryBean from the org.springframework.orm.hibernate4 package. Although it shares a name with the LocalSessionFactoryBean from the Hibernate 3 package 
Hibernate 4.0 and annotation-oriented persistence
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
	LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
	sfb.setDataSource(dataSource);
	sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}
@Repository
public class HibernateEmpRepository{
	public HibernateEmpRepository(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}
	private Session currentSession() {
		return sessionFactory.getCurrentSession();
	}
}

//spring JPA
LocalEntityManagerFactoryBean produces an application-managed EntityManagerFactory.
LocalContainerEntityManagerFactoryBean produces a container-managed EntityManagerFactory.
persistence.xml(This file must appear inthe META-INF directory in the classpath)
<persistence-unit name="spitterPU">
</persistence-unit>
@Bean
public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
	LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean();
	emfb.setPersistenceUnitName("spitterPU");
	return emfb;
}
CONFIGURING CONTAINER-MANAGED JPA
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory(
	DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
	emfb.setDataSource(dataSource);
	emfb.setJpaVendorAdapter(jpaVendorAdapter);
	emfb.setPackagesToScan("com.habuma.spittr.domain");
	return emfb;
}
@Bean
public JpaVendorAdapter jpaVendorAdapter() {
	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();//different classes based on JPA implimentaion
	//OpenJpaVendorAdapter adapter = new OpenJpaVendorAdapter()
	adapter.setDatabase("HSQL");//ORACLE for Oracle and DB2 for DB2
	adapter.setShowSql(true);
	adapter.setGenerateDdl(false);
	adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
	return adapter;
}
//ENTITYMANAGERFACTORY FROM JNDI
@Bean
public JndiObjectFactoryBean entityManagerFactory() {}
	JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
	jndiObjectFB.setJndiName("jdbc/SpittrDS");
	return jndiObjectFB;
}
//Spring-free JPA repositories(without JpaTemplete)
@Repository
@Transactional
public class JpaSpitterRepository implements SpitterRepository {
	@PersistenceUnit
	private EntityManagerFactory emf;
	public void addSpitter(Spitter spitter) {
		emf.createEntityManager().persist(spitter);
	}
	public Spitter getSpitterById(long id) {
		return emf.createEntityManager().find(Spitter.class, id);
	}
}

###########################
properties
###########################
reading properties with @PropertySource and @Value
config.properties
	mongodb.url=1.2.3.4
	mongodb.db=hello
@Configuration
@ComponentScan(basePackages = { "com.mkyong.*" })
@PropertySource("classpath:config.properties")
public class AppConfigMongoDB {
	//1.2.3.4
	@Value("${mongodb.url}")
	private String mongodbUrl;
	//hello
	@Value("${mongodb.db}")
	private String defaultDb;

	@Bean
	public MongoTemplate mongoTemplate() throws Exception {
		MongoClient mongo = new MongoClient(mongodbUrl, mongoOptions);
		MongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(mongo, defaultDb);
		return new MongoTemplate(mongoDbFactory);
	}
}
reading properties with @PropertySource and Environment
@Configuration
@ComponentScan(basePackages = { "com.mkyong.*" })
@PropertySource("classpath:config.properties")
public class AppConfigMongoDB {
	@Autowired
	private Environment env;
	@Bean
	public MongoTemplate mongoTemplate() throws Exception {
		String mongodbUrl = env.getProperty("mongodb.url");
		String defaultDb = env.getProperty("mongodb.db");
	}
}
configure multiple files
	@PropertySource({
		"classpath:config.properties",
		"classpath:db.properties" //if same key, this will 'win'
	})
configure multiple files in spring 4
	@PropertySources({
		@PropertySource("classpath:config.properties"),
		@PropertySource("classpath:db.properties")
	})
XML-based configuration
<beans>
    <context:property-placeholder location="classpath:com/example/app.properties"/>
</beans>
########################################################
############ Spring transaction                   ###### 
########################################################
Spring declarative transaction management addresses these concerns by using Aspect Oriented Programming to achieve loose coupling and avoid boiler-plate code in our application.
Spring 3.1 introduces the @EnableTransactionManagement annotation to be used in on @Configuration classes and enable transactional support.
@Configuration
@EnableTransactionManagement
public class PersistenceJPAConfig{
 
   @Bean
   public LocalContainerEntityManagerFactoryBean  entityManagerFactoryBean(){
      //...
   }
 
   @Bean
   public PlatformTransactionManager transactionManager(){
      JpaTransactionManager transactionManager = new JpaTransactionManager();
      transactionManager.setEntityManagerFactory( entityManagerFactoryBean().getObject() );
      return transactionManager;
   }
}
only public methods should be annotated with @Transactional
@Transactional
public void businessLogic() {
... use entity manager inside a transaction ...
}
You can change transaction isolation level – as follows
@Transactional(isolation = Isolation.SERIALIZABLE)
Note that this has actually been introduced in Spring 4.1
Isolation.READ_COMMITTED is default isolation level, so it only prevents dirty reads.
READ_UNCOMMITTED
READ_COMMITTED prevents Dirty Reads
REPEATABLE_READ prevents Dirty Reads and Non-Repeatable Reads
SERIALIZABLE prevents Dirty Reads, Non-Repeatable Reads and Phantom Read

Dirty Reads
-----------------
A> modifys R not commited
B> reads R
A>roll backs R
Non-Repeatable Reads
--------------------
A> reads R
B> modifs R and commits R
A> reads R( we get diff value)
Phantom Read
--------------
A> reads ange of R's
B>inserts new R in same region and commits
A>reads again same region( we get new records)

propagation
-----------------------
@Transactional(propagation=Propagation.REQUIRED)
the default propagational behavior is REQUIRED
Other options are REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER, and NESTED.

org.springframework.jdbc.datasource.DataSourceTransactionManager
org.springframework.orm.hibernate3.HibernateTransactionManager
org.springframework.orm.jpa.JpaTransactionManager

JDBC transaction
------------------------
<bean id="tjtJTransactionManager"
  class="org.springframework.jdbc.datasource.DataSourceTransactionManager"
  scope="singleton">
  <property name="dataSource" ref="tjtDataSource" />
</bean>
<tx:annotation-driven transaction-manager="tjtJTransactionManager" />

  @Transactional("tjtJTransactionManager")
  public void save(final String value) {
    dao.insert("T1", value);
  }
JPA
---------------------------------
<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
   <property name="entityManagerFactory" ref="myEmf" />
</bean>
<tx:annotation-driven transaction-manager="txManager" />
@Service
@Transactional
public class FooService {
    //...
} 
Hibernate
---------------------------------
  <bean id="transactionManager"
    class="org.springframework.orm.hibernate4.HibernateTransactionManager" 
    p:sessionFactory-ref="sessionFactory">
  </bean>

########################################################
############ Secure RESTful with spring security  ######
########################################################
Basic Authentication

step 1:create class extending WebSecurityConfigurerAdapter
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    private static String REALM="MY_TEST_REALM";
    @Autowired
    public void configureGlobalSecurity(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().withUser("bill").password("abc123").roles("ADMIN");
        auth.inMemoryAuthentication().withUser("tom").password("abc123").roles("USER");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
      http.csrf().disable()
        .authorizeRequests()
        .antMatchers("/user/**").hasRole("ADMIN")
        .and().httpBasic().realmName(REALM).authenticationEntryPoint(getBasicAuthEntryPoint())
        .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);//We don't need sessions to be created.
    }
    @Bean
    public CustomBasicAuthenticationEntryPoint getBasicAuthEntryPoint(){
        return new CustomBasicAuthenticationEntryPoint();
    }
    /* To allow Pre-flight [OPTIONS] request from browser */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(HttpMethod.OPTIONS, "/**");
    }
}
Step 2: create entry point class extending BasicAuthenticationEntryPoint
public class CustomBasicAuthenticationEntryPoint extends BasicAuthenticationEntryPoint {
    @Override
    public void commence(final HttpServletRequest request, 
            final HttpServletResponse response, 
            final AuthenticationException authException) throws IOException, ServletException {
        //Authentication failed, send error response.
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.addHeader("WWW-Authenticate", "Basic realm=" + getRealmName() + "");
        PrintWriter writer = response.getWriter();
        writer.println("HTTP Status 401 : " + authException.getMessage());
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        setRealmName("MY_TEST_REALM");
        super.afterPropertiesSet();
    }
}
step 3: no changes in restcontroller

########################################################
############ security for MVC         ################## 
########################################################
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	  auth.inMemoryAuthentication().withUser("mkyong").password("123456").roles("USER");
	  auth.inMemoryAuthentication().withUser("admin").password("123456").roles("ADMIN");
	  auth.inMemoryAuthentication().withUser("dba").password("123456").roles("DBA");
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {

	  http.authorizeRequests()
		.antMatchers("/admin/**").access("hasRole('ROLE_ADMIN')")
		.antMatchers("/dba/**").access("hasRole('ROLE_ADMIN') or hasRole('ROLE_DBA')")
		.and().formLogin();
		
	}
}
html equilavent

security.xml
	<http auto-config="true">
		<intercept-url pattern="/admin**" access="ROLE_ADMIN" />
		<intercept-url pattern="/dba**" access="ROLE_ADMIN,ROLE_DBA" />
	</http>

	<authentication-manager>
	  <authentication-provider>
	    <user-service>
		<user name="mkyong" password="123456" authorities="ROLE_USER" />
		<user name="admin" password="123456" authorities="ROLE_ADMIN" />
		<user name="dba" password="123456" authorities="ROLE_DBA" />
	    </user-service>
	  </authentication-provider>
	</authentication-manager>


import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;

public class SpringSecurityInitializer extends AbstractSecurityWebApplicationInitializer {
   //do nothing
}
html equilavent
web.xml
	<filter>
		<filter-name>springSecurityFilterChain</filter-name>
		<filter-class>org.springframework.web.filter.DelegatingFilterProxy
                </filter-class>
	</filter>

	<filter-mapping>
		<filter-name>springSecurityFilterChain</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>


########################################################
############ Spring loging                        ######
########################################################
#logging.level.root=debug
logging.level.org.hibernate.SQL=debug
logging.file=logs/app1.log
// with slf4j method internally uses logback implimentaion
package com.example.demo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
public class One {
	private static final Logger LOGGER = LoggerFactory.getLogger(One.class);
	@GetMapping(path="/one")
	public String mone() {
		LOGGER.info("****************");
		LOGGER.debug("****************");
		return "";
	}
}
by default log level is info
application.properties
logging.level.root=debug
//with log4j: we need to add required jars
note log4j also use slf4j internally
package com.example.demo;
import org.apache.log4j.Logger;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
public class One {
	private static final Logger LOGGER = Logger.getLogger(One.class);
	@GetMapping(path="/one")
	public String mone() {
		LOGGER.info("****************");
		LOGGER.debug("****************");
		return "";
	}
}
//logging with logback
create logback.xml in resource
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<property name="DEV_HOME" value="logs" />
	<appender name="FILE-AUDIT"
		class="ch.qos.logback.core.rolling.RollingFileAppender">
		<file>${DEV_HOME}/debug.log</file>
		<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
			<Pattern>
				%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
			</Pattern>
		</encoder>
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<!-- rollover daily -->
			<fileNamePattern>${DEV_HOME}/archived/debug.%d{yyyy-MM-dd}.%i.log
                        </fileNamePattern>
			<timeBasedFileNamingAndTriggeringPolicy
				class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
				<maxFileSize>10MB</maxFileSize>
			</timeBasedFileNamingAndTriggeringPolicy>
		</rollingPolicy>
	</appender>
	<logger name="com.example.demo" level="debug" additivity="false">
		<appender-ref ref="FILE-AUDIT" />
	</logger>
	<root level="info">
		<appender-ref ref="FILE-AUDIT" />
	</root>
</configuration>



######################################################################
################        Java Brains  Spring framework           ######
######################################################################
01. understanding Dependency injection
assume that we have code which create objects of Triangle and Cricle class and calls Draw method.
to remove dependency intraduce Interface Shape with draw method. Now code has Shape at left side of instantion 
Shape s = New Trangle()
But still we have Triangle and Cricle calls in code
to remove dependence create method that takes Shape as paraqmeter and other class pass actual object
doIt(Shape s){s.draw()}
So now depency moved to other class. Spring plays the other class role
04
BeanFactory f = new XmlBeanFactory(new FileSystemResource("abc.xml"));
Triangle t= (Triangle)f.getBean("b1");
05
ApplicationContext c = new ClassPathXmlApplicationContext("abc.xml");
Triangle t= (Triangle)c.getBean("b1");
we can use message resorce with application context
we can use event handling with application context
08
inner bean configuration when bean is not used for other beans
<bean id="" class="">
 <property name="" ref=""/>
 <property name="" >
	<bean class="">
		<property name="" value=""/>
	</bean>
 </property>
</bean>
10
in autowiring bean ids should be as as property names.
<bean id="" class="" autowire="byNmae" scope="singleton">
</bean>
autowire="byType" inthis case you shloud have only one bean config for one type in xml
autowire="constructor" works as same bytpe here also condition is you shloud have only one bean config for one type in xml
by default no autowire works
11
default scope is Singleton and initilises at context creation time and one object for one context
Prototype- new object everytime we call getBean() or referencing
Request, Session
12
how to get bean out side of spring bean: Impliment ApplicationContextWare to use getBean method.
or save application contect in Session or Singltion class and get context and call getBean method
when we need ApplicationContextWare is assume like Bean one is defined as single and we need dependent beans as new copy even though
we define dependent beans as proptoty we do not get fresh copy as it bean one is defined as singleton
13
bean defenation inheritance
<bean id="parentTriangle" class="com.eswar.reddy.Triangle">
 <property name="preNmae1" ref="bean1"/>
</bean>
<bean id="triangle1" class="com.eswar.reddy.Triangle" parent="parentTriangle">
 <property name="preNmae2" ref="bean2"/>
</bean>
with lists
<bean id="parentTriangle" class="com.eswar.reddy.Triangle">
 <property name="preNmae">
	<list>
			<ref bean="id1"/>
	</list>
 </property>
</bean>
<bean id="triangle1" class="com.eswar.reddy.Triangle" parent="parentTriangle">
 <property name="preNmae">
	<list merge="true">
			<ref bean="id2"/>
	</list>
 </property>
</bean>
14
bean life cycles
InitilizingBean.afterPropertiesSet()
Disposablebean.destroy()
AbstractApplicationContext.registerShutdownHook()
or 
<bean id="parentTriangle" class="com.eswar.reddy.Triangle" init-method="mone" destroy-method="mtwo">
AbstractApplicationContext.registerShutdownHook()
16
propertyPlaceholderConfigure
<bean id="parentTriangle" class="com.eswar.reddy.Triangle">
 <property name="preNmae" value="${com.pro1}">
</bean>
<bean class="org.spring.propertyPlaceholderConfigure>
 <property name="locations" value="propertiesFile1">
</bean>
18
@required
public void setPro1(...){}
<bean class="org.springframework....RequiredAnnotationBeanPostProcesser"> or <context:annotation-config/>
19
@Autowired
public void setPro1(...){}
<bean class="org.springframework....AutowiredAnnotationBeanPostProcesser">
or <context:annotation-config/>

@Autowired
@Qualifier("qu1")
public void setPro1(...){}
<bean class="org.springframework....AutowiredAnnotationBeanPostProcesser">
or <context:annotation-config/>
<bean id="id1" class="com.eswar.reddy.Triangle">
 <qualifier value="qu1"
 <property name="preNmae" value="xyz">
</bean>
 and namespaces should be added in xml
20
JSR250
@Resource
public void setPro1(...){}
@Resource(name="p1")
public void setPro1(...){}

@PostConstructor
public void m1(...){}
@PreDestroy
public void m1(...){}
AbstractApplicationContext.registerShutdownHook()

21
@Component
public class Cricle{
}
<context:componentscan base-package="org.abc"/>
steriotype annotation component disadvatage is we can not define once calss with multiple names(multiple defenation)
@Controller
@Repositry
@Service

22
<bean id="messageSource" class="org.springframework....ResourceBundleMessageSource">
	<property name="basenames">
		<list><value>mymessages</value></list>
	</property>
</bean>
@Autowired
private MessageSource ms;
in any method this.ms.getMessage("mkey1",null,"default message", null)

context.getMessage("mkey1",null,"default message", null)
23
ApplicationEventpublishAware
ApplicationEventPublisher.publishEvent()

to create event extend ApplicationEvent
to create listener extend ApplicationListner

<context:component-scan/>

###############################################################################
###################       Spring boot java brains   ###########################
###############################################################################

12
JSON object output
@RestController
public class Contoller1 {
	@RequestMapping("/topics")
	public List<Topic> hello() {
		return Arrays.asList(new Topic("abc","xyz"),new Topic("123","pqr"));
	}
}
public class Topic {
	private String name;
	private String name1;
	Topic(String name,String name1){this.name=name;this.name1=name1;}
	//settters and getters
}

17 and 18
add service layer and request parameter
@RestController
public class Contoller1 {
	@Autowired
	private Service1 service;
	@RequestMapping("/topics/{id}")
	public List<Topic> topics(@PathVariable("id") String x) {
		System.out.println(x);
		return service.topics();
	}
}
@Service
public class Service1 {
	public List<Topic> topics() {
		return Arrays.asList(new Topic("abc","xyz"),new Topic("123","pqr"));
	}
}
19
how to handle post request(@RequestBody)
@RestController
public class Contoller1 {
	@Autowired
	private Service1 service;
	@RequestMapping(method=RequestMethod.POST, value="/topics/")
	public void addTopic(@RequestBody Topic topic) {
		return service.addTopic(topic);
	}
}
use postman plugin in chrome to test
20
@RestController
public class Contoller1 {
	@Autowired
	private Service1 service;
	@RequestMapping(method=RequestMethod.PUT, value="/topics/{id}")
	public void updateTopic(@RequestBody Topic topic,@PathVariable("id") String x) {
		return service.updateTopic(topic,x);
	}
}
by default spring restController returns JSON format
for XML format we need to add @XmlRootElement in custom return type class
@RequestMapping(method=RequestMethod.GET, value="hello5", produces=MediaType.APPLICATION_XML_VALUE)
	public Topic1 mone5() {
		return new Topic1("name1","desc1");
	}
@XmlRootElement
public class Topic {
}
25
How to change port
resource/application.properties
server.port=8081

28
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
 mvn install:install-file -Dfile=C:\1work\jars\ORM_HOME\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=12.1.0 -Dpackaging=jar

@Entity
public class Topic {
	@Id
	private String id;
	private String name;
	private String name1;
}
29
@Service
public class Service1 {
	@Autowired
	private TopicRepository dao;
	public Topic getTopic(String id) {
		return dao.findOne(id);
	}
	public void saveTopic(Topic topic) {
		dao.save(topic);
	}
	public void updateTopic(String id, Topic topic) {
		dao.save(topic);
	}
	public void deleteTopic(String id) {
		dao.delete(id);
	}
	public List<Topic> topics() {
		List<Topic> topics = new ArrayList<>();
		dao.findAll().forEach(topics::add);
		return topics;
	}
}
public interface TopicRepository extends CrudRepository<Topic, String>{
	
}

for save and update we have only one method save in CrudRepository
CrudRepository takes two generic types one is Entity and another one is Id

31
whatch 30 and 31. very good


@SpringBootApplication can be replaced with @Configuration, @EnableAutoConfiguration, @ComponentScan({"main class package","contollers package"})
add below properties in application.properties to support Views
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

	@Id
	@SequenceGenerator(name="emailAddress.generator", sequenceName="AFP_AWD.EMAIL_ADDR_SEQ")	
	@GeneratedValue(strategy=GenerationType.SEQUENCE, generator = "emailAddress.generator")
	@Column(name = "EMAIL_ADDR_SID")
	private long id;


**********************************************
*************     Spring 2.5      ************
**********************************************
web.xml
	<servlet>
		<servlet-name>mvc-dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring-mvc-config.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>


  <servlet-mapping>
 	<servlet-name>mvc-dispatcher</servlet-name>
        <url-pattern>*.htm</url-pattern>
  </servlet-mapping>
  
mvc-dispatcher-servlet.xml

    <bean name="/welcome.htm"
		class="com.mkyong.common.controller.HelloWorldController" />

    <bean id="viewResolver"
    	class="org.springframework.web.servlet.view.InternalResourceViewResolver" >
        <property name="prefix">
            <value>/WEB-INF/pages/</value>
        </property>
        <property name="suffix">
            <value>.jsp</value>
        </property>
    </bean>
	
	<context:component-scan base-package="com.mkyong.common.controller" />

public class HelloWorldController extends AbstractController{
	@Override
	protected ModelAndView handleRequestInternal(HttpServletRequest request,
		HttpServletResponse response) throws Exception {
		ModelAndView model = new ModelAndView("HelloWorldPage");
		model.addObject("msg", "hello world");
		return model;
	}
}

#######################################################
           Spring 3
#######################################################


<bean id="a" class="org.sssit.A" autowire="byName"></bean>  
<bean id="a" class="org.sssit.A" autowire="byType"></bean>  
<bean id="a" class="org.sssit.A" autowire="constructor"></bean>  

1) A static factory method that returns instance of its own class. It is used in singleton design pattern.
public class A {  
	private static final A obj=new A();  
	private A(){System.out.println("private constructor");}  
	public static A getA(){  
		System.out.println("factory method ");  
		return obj;  
	} 
}
<bean id="a" class="com.javatpoint.A" factory-method="getA"></bean>  

2)A non-static factory method that returns instance of another class. It is used instance is not known and decided at runtime.
public class PrintableFactory {  
	//non-static factory method  
	public Printable getPrintable(){  
		return new A();//return any one instance, either A or B  
	}  
}  
<bean id="pfactory" class="com.javatpoint.PrintableFactory"></bean>  
<bean id="p" class="com.javatpoint.PrintableFactory" factory-method="getPrintable"  factory-bean="pfactory"></bean> 

3. A static factory method that returns instance of another class. It is used instance is not known and decided at runtime.
<bean id="b" class="com.javatpoint.A" factory-method="getB"></bean>  
public interface Printable {  
	void print();  
} 
public class A implements Printable{  
    @Override  
    public void print() {  
        System.out.println("hello a");  
    }  
}  
 And we have Class B also like class A
 public class PrintableFactory {  
	public static Printable getPrintable(){  
		//return new B();  
			return new A();//return any one instance, either A or B  
}



////////////////////////////////////////////////////////////////
we need to add Oracle driver extranally to spring boot(ojdbc14 does not work)
		<dependency>
            <groupId>com.oracle</groupId>
            <artifactId>ojdbc6</artifactId>
            <version>11.2.0.3.0</version>
        </dependency>
  <repositories>
    <repository>
      <id>com.oracle</id>
      <url>http://afpbuildserver:8081/nexus/content/repositories/thirdparty</url>
    </repository>
  </repositories>

server.port=8081
  
spring.datasource.url=jdbc:oracle:thin:@dcup62d.us.aegon.com:1831:DAFPADM
spring.datasource.username=emummasani
spring.datasource.password=WAR1234
spring.datasource.driver-class=oracle.jdbc.driver.OracleDriver
spring.datasource.hikari.connection-timeout=60000
spring.datasource.hikari.maximum-pool-size=5
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
logging.level.org.hibernate.SQL=debug


we can confiure log4j without any issues by just adding jars in pom.xml and log4j properties in resource folder


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@      POC            @@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
simple app1 (rest webservice with h2 database)
----------------------------------------------
	https://start.spring.io/
	version 2.1.5
	Spring web Starter
	Spring Data JPA
	H2 database
one.java	
	package com.example.demo;

	import org.springframework.boot.SpringApplication;
	import org.springframework.boot.autoconfigure.SpringBootApplication;

	@SpringBootApplication
	public class DemoApplication {
		public static void main(String[] args) {
			SpringApplication.run(DemoApplication.class, args);
		}
	}	

Testing
http://localhost:8080/one

simple app2 (how to access h2 database)
----------------------------
add below thing to app1
application.properties
	spring.h2.console.settings.trace=true
	spring.datasource.driver-class-name=org.h2.Driver
	spring.datasource.url=jdbc:h2:mem:tt_data_arl;DB_CLOSE_DELAY=-1
	spring.datasource.username=test
	spring.datasource.password=pass
	spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
data.sql
	CREATE SCHEMA IF NOT EXISTS tt_data_arl;
	DROP TABLE IF EXISTS tt_data_arl.master_agent_reference;

Testing
	http://localhost:8080/h2-console/


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@      FAQ            @@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
get bean with Beanfactory
get bean with ApplicationContext
use setter injection
use constructor injection
injects objects
get bean using alias ,name ,id,idref
list and maps
get dependecy with autowire
scopes Singleton and proptotype
bean defination inheritance with lists
what is factory method use in dependency
how to read properties
	@Value("key1")
How to configure objects that have been created outside the control of an IoC container.
how to instantiate a Spring IoC container
how to solve Circular Dependency in spring
how to build spring mavc with spring boot

What is maximum payload in post in RESTful
Different kind of rest methods
Rest status codes
URL versioning 
Rest security
how to handle logging
how to handle exceptions
How to read external properties
Integration testing
File/Image sending through RestFul
how to combine declarative and programetic transactions

SPring+ JPA+ transactions
	JpaTransactionManager it needs LocalContainerEntityManagerFactoryBean
	LocalContainerEntityManagerFactoryBean needs DataSource and JpaVendorAdapter
	JpaVendorAdapter is HibernateJpaVendorAdapter
	@Transactional(isolation = Isolation.SERIALIZABLE)
	When using JPA outside of a dependency injection container, transactions need 
	to be handled programatically by the developer:
	@PersistenceContext
	private EntityManager em;
	UserTransaction utx = entityManager.getTransaction(); 
	utx.begin();utx.commit();utx.rollback(); 
	propagation: REQUIRED, REQUIRES_NEW, MANDATORY, NESTED, SUPPORTS
	isolation:DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, SERIALIZABLE 
	DEFAULT is lets DB to deceide it
	readOnly - whether the transaction is read-only or read/write
	timeout — transaction timeout
Spring logging with AOP
	ImportAware
	ApplicationListener
	@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
	@Target(value = { java.lang.annotation.ElementType.TYPE })
	@Documented
	@Import({LoggerHeaderConfigurator.class})
	public @interface EnableLoggerHeader {





 






 
























